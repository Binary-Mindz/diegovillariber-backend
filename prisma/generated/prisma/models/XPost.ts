
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `XPost` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model XPost
 * 
 */
export type XPostModel = runtime.Types.Result.DefaultSelection<Prisma.$XPostPayload>

export type AggregateXPost = {
  _count: XPostCountAggregateOutputType | null
  _avg: XPostAvgAggregateOutputType | null
  _sum: XPostSumAggregateOutputType | null
  _min: XPostMinAggregateOutputType | null
  _max: XPostMaxAggregateOutputType | null
}

export type XPostAvgAggregateOutputType = {
  like: number | null
  comment: number | null
  share: number | null
}

export type XPostSumAggregateOutputType = {
  like: number | null
  comment: number | null
  share: number | null
}

export type XPostMinAggregateOutputType = {
  id: string | null
  userId: string | null
  battleId: string | null
  battleParticipantId: string | null
  challengeId: string | null
  challengeParticipantId: string | null
  postType: $Enums.PostType | null
  mediaUrl: string | null
  caption: string | null
  like: number | null
  comment: number | null
  share: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type XPostMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  battleId: string | null
  battleParticipantId: string | null
  challengeId: string | null
  challengeParticipantId: string | null
  postType: $Enums.PostType | null
  mediaUrl: string | null
  caption: string | null
  like: number | null
  comment: number | null
  share: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type XPostCountAggregateOutputType = {
  id: number
  userId: number
  battleId: number
  battleParticipantId: number
  challengeId: number
  challengeParticipantId: number
  postType: number
  mediaUrl: number
  caption: number
  like: number
  comment: number
  share: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type XPostAvgAggregateInputType = {
  like?: true
  comment?: true
  share?: true
}

export type XPostSumAggregateInputType = {
  like?: true
  comment?: true
  share?: true
}

export type XPostMinAggregateInputType = {
  id?: true
  userId?: true
  battleId?: true
  battleParticipantId?: true
  challengeId?: true
  challengeParticipantId?: true
  postType?: true
  mediaUrl?: true
  caption?: true
  like?: true
  comment?: true
  share?: true
  createdAt?: true
  updatedAt?: true
}

export type XPostMaxAggregateInputType = {
  id?: true
  userId?: true
  battleId?: true
  battleParticipantId?: true
  challengeId?: true
  challengeParticipantId?: true
  postType?: true
  mediaUrl?: true
  caption?: true
  like?: true
  comment?: true
  share?: true
  createdAt?: true
  updatedAt?: true
}

export type XPostCountAggregateInputType = {
  id?: true
  userId?: true
  battleId?: true
  battleParticipantId?: true
  challengeId?: true
  challengeParticipantId?: true
  postType?: true
  mediaUrl?: true
  caption?: true
  like?: true
  comment?: true
  share?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type XPostAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which XPost to aggregate.
   */
  where?: Prisma.XPostWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of XPosts to fetch.
   */
  orderBy?: Prisma.XPostOrderByWithRelationInput | Prisma.XPostOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.XPostWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` XPosts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` XPosts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned XPosts
  **/
  _count?: true | XPostCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: XPostAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: XPostSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: XPostMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: XPostMaxAggregateInputType
}

export type GetXPostAggregateType<T extends XPostAggregateArgs> = {
      [P in keyof T & keyof AggregateXPost]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateXPost[P]>
    : Prisma.GetScalarType<T[P], AggregateXPost[P]>
}




export type XPostGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.XPostWhereInput
  orderBy?: Prisma.XPostOrderByWithAggregationInput | Prisma.XPostOrderByWithAggregationInput[]
  by: Prisma.XPostScalarFieldEnum[] | Prisma.XPostScalarFieldEnum
  having?: Prisma.XPostScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: XPostCountAggregateInputType | true
  _avg?: XPostAvgAggregateInputType
  _sum?: XPostSumAggregateInputType
  _min?: XPostMinAggregateInputType
  _max?: XPostMaxAggregateInputType
}

export type XPostGroupByOutputType = {
  id: string
  userId: string
  battleId: string | null
  battleParticipantId: string | null
  challengeId: string | null
  challengeParticipantId: string | null
  postType: $Enums.PostType
  mediaUrl: string | null
  caption: string | null
  like: number
  comment: number
  share: number
  createdAt: Date
  updatedAt: Date
  _count: XPostCountAggregateOutputType | null
  _avg: XPostAvgAggregateOutputType | null
  _sum: XPostSumAggregateOutputType | null
  _min: XPostMinAggregateOutputType | null
  _max: XPostMaxAggregateOutputType | null
}

type GetXPostGroupByPayload<T extends XPostGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<XPostGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof XPostGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], XPostGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], XPostGroupByOutputType[P]>
      }
    >
  >



export type XPostWhereInput = {
  AND?: Prisma.XPostWhereInput | Prisma.XPostWhereInput[]
  OR?: Prisma.XPostWhereInput[]
  NOT?: Prisma.XPostWhereInput | Prisma.XPostWhereInput[]
  id?: Prisma.UuidFilter<"XPost"> | string
  userId?: Prisma.UuidFilter<"XPost"> | string
  battleId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  battleParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  postType?: Prisma.EnumPostTypeFilter<"XPost"> | $Enums.PostType
  mediaUrl?: Prisma.StringNullableFilter<"XPost"> | string | null
  caption?: Prisma.StringNullableFilter<"XPost"> | string | null
  like?: Prisma.IntFilter<"XPost"> | number
  comment?: Prisma.IntFilter<"XPost"> | number
  share?: Prisma.IntFilter<"XPost"> | number
  createdAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  battle?: Prisma.XOR<Prisma.BattleNullableScalarRelationFilter, Prisma.BattleWhereInput> | null
  battleParticipant?: Prisma.XOR<Prisma.BattleParticipantNullableScalarRelationFilter, Prisma.BattleParticipantWhereInput> | null
  challenge?: Prisma.XOR<Prisma.ChallengeNullableScalarRelationFilter, Prisma.ChallengeWhereInput> | null
  challengeParticipant?: Prisma.XOR<Prisma.ChallengeParticipantNullableScalarRelationFilter, Prisma.ChallengeParticipantWhereInput> | null
  challengeSubmission?: Prisma.XOR<Prisma.ChallengeSubmissionNullableScalarRelationFilter, Prisma.ChallengeSubmissionWhereInput> | null
  battleEntries?: Prisma.BattleEntryListRelationFilter
}

export type XPostOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  battleId?: Prisma.SortOrderInput | Prisma.SortOrder
  battleParticipantId?: Prisma.SortOrderInput | Prisma.SortOrder
  challengeId?: Prisma.SortOrderInput | Prisma.SortOrder
  challengeParticipantId?: Prisma.SortOrderInput | Prisma.SortOrder
  postType?: Prisma.SortOrder
  mediaUrl?: Prisma.SortOrderInput | Prisma.SortOrder
  caption?: Prisma.SortOrderInput | Prisma.SortOrder
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  battle?: Prisma.BattleOrderByWithRelationInput
  battleParticipant?: Prisma.BattleParticipantOrderByWithRelationInput
  challenge?: Prisma.ChallengeOrderByWithRelationInput
  challengeParticipant?: Prisma.ChallengeParticipantOrderByWithRelationInput
  challengeSubmission?: Prisma.ChallengeSubmissionOrderByWithRelationInput
  battleEntries?: Prisma.BattleEntryOrderByRelationAggregateInput
}

export type XPostWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.XPostWhereInput | Prisma.XPostWhereInput[]
  OR?: Prisma.XPostWhereInput[]
  NOT?: Prisma.XPostWhereInput | Prisma.XPostWhereInput[]
  userId?: Prisma.UuidFilter<"XPost"> | string
  battleId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  battleParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  postType?: Prisma.EnumPostTypeFilter<"XPost"> | $Enums.PostType
  mediaUrl?: Prisma.StringNullableFilter<"XPost"> | string | null
  caption?: Prisma.StringNullableFilter<"XPost"> | string | null
  like?: Prisma.IntFilter<"XPost"> | number
  comment?: Prisma.IntFilter<"XPost"> | number
  share?: Prisma.IntFilter<"XPost"> | number
  createdAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  battle?: Prisma.XOR<Prisma.BattleNullableScalarRelationFilter, Prisma.BattleWhereInput> | null
  battleParticipant?: Prisma.XOR<Prisma.BattleParticipantNullableScalarRelationFilter, Prisma.BattleParticipantWhereInput> | null
  challenge?: Prisma.XOR<Prisma.ChallengeNullableScalarRelationFilter, Prisma.ChallengeWhereInput> | null
  challengeParticipant?: Prisma.XOR<Prisma.ChallengeParticipantNullableScalarRelationFilter, Prisma.ChallengeParticipantWhereInput> | null
  challengeSubmission?: Prisma.XOR<Prisma.ChallengeSubmissionNullableScalarRelationFilter, Prisma.ChallengeSubmissionWhereInput> | null
  battleEntries?: Prisma.BattleEntryListRelationFilter
}, "id">

export type XPostOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  battleId?: Prisma.SortOrderInput | Prisma.SortOrder
  battleParticipantId?: Prisma.SortOrderInput | Prisma.SortOrder
  challengeId?: Prisma.SortOrderInput | Prisma.SortOrder
  challengeParticipantId?: Prisma.SortOrderInput | Prisma.SortOrder
  postType?: Prisma.SortOrder
  mediaUrl?: Prisma.SortOrderInput | Prisma.SortOrder
  caption?: Prisma.SortOrderInput | Prisma.SortOrder
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.XPostCountOrderByAggregateInput
  _avg?: Prisma.XPostAvgOrderByAggregateInput
  _max?: Prisma.XPostMaxOrderByAggregateInput
  _min?: Prisma.XPostMinOrderByAggregateInput
  _sum?: Prisma.XPostSumOrderByAggregateInput
}

export type XPostScalarWhereWithAggregatesInput = {
  AND?: Prisma.XPostScalarWhereWithAggregatesInput | Prisma.XPostScalarWhereWithAggregatesInput[]
  OR?: Prisma.XPostScalarWhereWithAggregatesInput[]
  NOT?: Prisma.XPostScalarWhereWithAggregatesInput | Prisma.XPostScalarWhereWithAggregatesInput[]
  id?: Prisma.UuidWithAggregatesFilter<"XPost"> | string
  userId?: Prisma.UuidWithAggregatesFilter<"XPost"> | string
  battleId?: Prisma.UuidNullableWithAggregatesFilter<"XPost"> | string | null
  battleParticipantId?: Prisma.UuidNullableWithAggregatesFilter<"XPost"> | string | null
  challengeId?: Prisma.UuidNullableWithAggregatesFilter<"XPost"> | string | null
  challengeParticipantId?: Prisma.UuidNullableWithAggregatesFilter<"XPost"> | string | null
  postType?: Prisma.EnumPostTypeWithAggregatesFilter<"XPost"> | $Enums.PostType
  mediaUrl?: Prisma.StringNullableWithAggregatesFilter<"XPost"> | string | null
  caption?: Prisma.StringNullableWithAggregatesFilter<"XPost"> | string | null
  like?: Prisma.IntWithAggregatesFilter<"XPost"> | number
  comment?: Prisma.IntWithAggregatesFilter<"XPost"> | number
  share?: Prisma.IntWithAggregatesFilter<"XPost"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"XPost"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"XPost"> | Date | string
}

export type XPostCreateInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostCreateManyInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostListRelationFilter = {
  every?: Prisma.XPostWhereInput
  some?: Prisma.XPostWhereInput
  none?: Prisma.XPostWhereInput
}

export type XPostOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type XPostNullableScalarRelationFilter = {
  is?: Prisma.XPostWhereInput | null
  isNot?: Prisma.XPostWhereInput | null
}

export type XPostScalarRelationFilter = {
  is?: Prisma.XPostWhereInput
  isNot?: Prisma.XPostWhereInput
}

export type XPostCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  battleId?: Prisma.SortOrder
  battleParticipantId?: Prisma.SortOrder
  challengeId?: Prisma.SortOrder
  challengeParticipantId?: Prisma.SortOrder
  postType?: Prisma.SortOrder
  mediaUrl?: Prisma.SortOrder
  caption?: Prisma.SortOrder
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type XPostAvgOrderByAggregateInput = {
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
}

export type XPostMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  battleId?: Prisma.SortOrder
  battleParticipantId?: Prisma.SortOrder
  challengeId?: Prisma.SortOrder
  challengeParticipantId?: Prisma.SortOrder
  postType?: Prisma.SortOrder
  mediaUrl?: Prisma.SortOrder
  caption?: Prisma.SortOrder
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type XPostMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  battleId?: Prisma.SortOrder
  battleParticipantId?: Prisma.SortOrder
  challengeId?: Prisma.SortOrder
  challengeParticipantId?: Prisma.SortOrder
  postType?: Prisma.SortOrder
  mediaUrl?: Prisma.SortOrder
  caption?: Prisma.SortOrder
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type XPostSumOrderByAggregateInput = {
  like?: Prisma.SortOrder
  comment?: Prisma.SortOrder
  share?: Prisma.SortOrder
}

export type XPostCreateNestedManyWithoutBattleInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput> | Prisma.XPostCreateWithoutBattleInput[] | Prisma.XPostUncheckedCreateWithoutBattleInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleInput | Prisma.XPostCreateOrConnectWithoutBattleInput[]
  createMany?: Prisma.XPostCreateManyBattleInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUncheckedCreateNestedManyWithoutBattleInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput> | Prisma.XPostCreateWithoutBattleInput[] | Prisma.XPostUncheckedCreateWithoutBattleInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleInput | Prisma.XPostCreateOrConnectWithoutBattleInput[]
  createMany?: Prisma.XPostCreateManyBattleInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUpdateManyWithoutBattleNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput> | Prisma.XPostCreateWithoutBattleInput[] | Prisma.XPostUncheckedCreateWithoutBattleInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleInput | Prisma.XPostCreateOrConnectWithoutBattleInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutBattleInput | Prisma.XPostUpsertWithWhereUniqueWithoutBattleInput[]
  createMany?: Prisma.XPostCreateManyBattleInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutBattleInput | Prisma.XPostUpdateWithWhereUniqueWithoutBattleInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutBattleInput | Prisma.XPostUpdateManyWithWhereWithoutBattleInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostUncheckedUpdateManyWithoutBattleNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput> | Prisma.XPostCreateWithoutBattleInput[] | Prisma.XPostUncheckedCreateWithoutBattleInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleInput | Prisma.XPostCreateOrConnectWithoutBattleInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutBattleInput | Prisma.XPostUpsertWithWhereUniqueWithoutBattleInput[]
  createMany?: Prisma.XPostCreateManyBattleInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutBattleInput | Prisma.XPostUpdateWithWhereUniqueWithoutBattleInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutBattleInput | Prisma.XPostUpdateManyWithWhereWithoutBattleInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostCreateNestedOneWithoutBattleEntriesInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleEntriesInput, Prisma.XPostUncheckedCreateWithoutBattleEntriesInput>
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleEntriesInput
  connect?: Prisma.XPostWhereUniqueInput
}

export type XPostUpdateOneWithoutBattleEntriesNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleEntriesInput, Prisma.XPostUncheckedCreateWithoutBattleEntriesInput>
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleEntriesInput
  upsert?: Prisma.XPostUpsertWithoutBattleEntriesInput
  disconnect?: Prisma.XPostWhereInput | boolean
  delete?: Prisma.XPostWhereInput | boolean
  connect?: Prisma.XPostWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.XPostUpdateToOneWithWhereWithoutBattleEntriesInput, Prisma.XPostUpdateWithoutBattleEntriesInput>, Prisma.XPostUncheckedUpdateWithoutBattleEntriesInput>
}

export type XPostCreateNestedManyWithoutBattleParticipantInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput> | Prisma.XPostCreateWithoutBattleParticipantInput[] | Prisma.XPostUncheckedCreateWithoutBattleParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleParticipantInput | Prisma.XPostCreateOrConnectWithoutBattleParticipantInput[]
  createMany?: Prisma.XPostCreateManyBattleParticipantInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUncheckedCreateNestedManyWithoutBattleParticipantInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput> | Prisma.XPostCreateWithoutBattleParticipantInput[] | Prisma.XPostUncheckedCreateWithoutBattleParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleParticipantInput | Prisma.XPostCreateOrConnectWithoutBattleParticipantInput[]
  createMany?: Prisma.XPostCreateManyBattleParticipantInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUpdateManyWithoutBattleParticipantNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput> | Prisma.XPostCreateWithoutBattleParticipantInput[] | Prisma.XPostUncheckedCreateWithoutBattleParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleParticipantInput | Prisma.XPostCreateOrConnectWithoutBattleParticipantInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutBattleParticipantInput | Prisma.XPostUpsertWithWhereUniqueWithoutBattleParticipantInput[]
  createMany?: Prisma.XPostCreateManyBattleParticipantInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutBattleParticipantInput | Prisma.XPostUpdateWithWhereUniqueWithoutBattleParticipantInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutBattleParticipantInput | Prisma.XPostUpdateManyWithWhereWithoutBattleParticipantInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostUncheckedUpdateManyWithoutBattleParticipantNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput> | Prisma.XPostCreateWithoutBattleParticipantInput[] | Prisma.XPostUncheckedCreateWithoutBattleParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutBattleParticipantInput | Prisma.XPostCreateOrConnectWithoutBattleParticipantInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutBattleParticipantInput | Prisma.XPostUpsertWithWhereUniqueWithoutBattleParticipantInput[]
  createMany?: Prisma.XPostCreateManyBattleParticipantInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutBattleParticipantInput | Prisma.XPostUpdateWithWhereUniqueWithoutBattleParticipantInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutBattleParticipantInput | Prisma.XPostUpdateManyWithWhereWithoutBattleParticipantInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostCreateNestedManyWithoutChallengeInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput> | Prisma.XPostCreateWithoutChallengeInput[] | Prisma.XPostUncheckedCreateWithoutChallengeInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeInput | Prisma.XPostCreateOrConnectWithoutChallengeInput[]
  createMany?: Prisma.XPostCreateManyChallengeInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUncheckedCreateNestedManyWithoutChallengeInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput> | Prisma.XPostCreateWithoutChallengeInput[] | Prisma.XPostUncheckedCreateWithoutChallengeInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeInput | Prisma.XPostCreateOrConnectWithoutChallengeInput[]
  createMany?: Prisma.XPostCreateManyChallengeInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUpdateManyWithoutChallengeNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput> | Prisma.XPostCreateWithoutChallengeInput[] | Prisma.XPostUncheckedCreateWithoutChallengeInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeInput | Prisma.XPostCreateOrConnectWithoutChallengeInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutChallengeInput | Prisma.XPostUpsertWithWhereUniqueWithoutChallengeInput[]
  createMany?: Prisma.XPostCreateManyChallengeInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutChallengeInput | Prisma.XPostUpdateWithWhereUniqueWithoutChallengeInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutChallengeInput | Prisma.XPostUpdateManyWithWhereWithoutChallengeInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostUncheckedUpdateManyWithoutChallengeNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput> | Prisma.XPostCreateWithoutChallengeInput[] | Prisma.XPostUncheckedCreateWithoutChallengeInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeInput | Prisma.XPostCreateOrConnectWithoutChallengeInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutChallengeInput | Prisma.XPostUpsertWithWhereUniqueWithoutChallengeInput[]
  createMany?: Prisma.XPostCreateManyChallengeInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutChallengeInput | Prisma.XPostUpdateWithWhereUniqueWithoutChallengeInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutChallengeInput | Prisma.XPostUpdateManyWithWhereWithoutChallengeInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostCreateNestedManyWithoutChallengeParticipantInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput> | Prisma.XPostCreateWithoutChallengeParticipantInput[] | Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput | Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput[]
  createMany?: Prisma.XPostCreateManyChallengeParticipantInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUncheckedCreateNestedManyWithoutChallengeParticipantInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput> | Prisma.XPostCreateWithoutChallengeParticipantInput[] | Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput | Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput[]
  createMany?: Prisma.XPostCreateManyChallengeParticipantInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUpdateManyWithoutChallengeParticipantNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput> | Prisma.XPostCreateWithoutChallengeParticipantInput[] | Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput | Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutChallengeParticipantInput | Prisma.XPostUpsertWithWhereUniqueWithoutChallengeParticipantInput[]
  createMany?: Prisma.XPostCreateManyChallengeParticipantInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutChallengeParticipantInput | Prisma.XPostUpdateWithWhereUniqueWithoutChallengeParticipantInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutChallengeParticipantInput | Prisma.XPostUpdateManyWithWhereWithoutChallengeParticipantInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostUncheckedUpdateManyWithoutChallengeParticipantNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput> | Prisma.XPostCreateWithoutChallengeParticipantInput[] | Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput | Prisma.XPostCreateOrConnectWithoutChallengeParticipantInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutChallengeParticipantInput | Prisma.XPostUpsertWithWhereUniqueWithoutChallengeParticipantInput[]
  createMany?: Prisma.XPostCreateManyChallengeParticipantInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutChallengeParticipantInput | Prisma.XPostUpdateWithWhereUniqueWithoutChallengeParticipantInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutChallengeParticipantInput | Prisma.XPostUpdateManyWithWhereWithoutChallengeParticipantInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostCreateNestedOneWithoutChallengeSubmissionInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedCreateWithoutChallengeSubmissionInput>
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeSubmissionInput
  connect?: Prisma.XPostWhereUniqueInput
}

export type XPostUpdateOneRequiredWithoutChallengeSubmissionNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedCreateWithoutChallengeSubmissionInput>
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutChallengeSubmissionInput
  upsert?: Prisma.XPostUpsertWithoutChallengeSubmissionInput
  connect?: Prisma.XPostWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.XPostUpdateToOneWithWhereWithoutChallengeSubmissionInput, Prisma.XPostUpdateWithoutChallengeSubmissionInput>, Prisma.XPostUncheckedUpdateWithoutChallengeSubmissionInput>
}

export type XPostCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput> | Prisma.XPostCreateWithoutUserInput[] | Prisma.XPostUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutUserInput | Prisma.XPostCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.XPostCreateManyUserInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput> | Prisma.XPostCreateWithoutUserInput[] | Prisma.XPostUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutUserInput | Prisma.XPostCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.XPostCreateManyUserInputEnvelope
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
}

export type XPostUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput> | Prisma.XPostCreateWithoutUserInput[] | Prisma.XPostUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutUserInput | Prisma.XPostCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutUserInput | Prisma.XPostUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.XPostCreateManyUserInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutUserInput | Prisma.XPostUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutUserInput | Prisma.XPostUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput> | Prisma.XPostCreateWithoutUserInput[] | Prisma.XPostUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.XPostCreateOrConnectWithoutUserInput | Prisma.XPostCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.XPostUpsertWithWhereUniqueWithoutUserInput | Prisma.XPostUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.XPostCreateManyUserInputEnvelope
  set?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  disconnect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  delete?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  connect?: Prisma.XPostWhereUniqueInput | Prisma.XPostWhereUniqueInput[]
  update?: Prisma.XPostUpdateWithWhereUniqueWithoutUserInput | Prisma.XPostUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.XPostUpdateManyWithWhereWithoutUserInput | Prisma.XPostUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
}

export type XPostCreateWithoutBattleInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutBattleInput = {
  id?: string
  userId: string
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutBattleInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput>
}

export type XPostCreateManyBattleInputEnvelope = {
  data: Prisma.XPostCreateManyBattleInput | Prisma.XPostCreateManyBattleInput[]
  skipDuplicates?: boolean
}

export type XPostUpsertWithWhereUniqueWithoutBattleInput = {
  where: Prisma.XPostWhereUniqueInput
  update: Prisma.XOR<Prisma.XPostUpdateWithoutBattleInput, Prisma.XPostUncheckedUpdateWithoutBattleInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleInput, Prisma.XPostUncheckedCreateWithoutBattleInput>
}

export type XPostUpdateWithWhereUniqueWithoutBattleInput = {
  where: Prisma.XPostWhereUniqueInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutBattleInput, Prisma.XPostUncheckedUpdateWithoutBattleInput>
}

export type XPostUpdateManyWithWhereWithoutBattleInput = {
  where: Prisma.XPostScalarWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyWithoutBattleInput>
}

export type XPostScalarWhereInput = {
  AND?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
  OR?: Prisma.XPostScalarWhereInput[]
  NOT?: Prisma.XPostScalarWhereInput | Prisma.XPostScalarWhereInput[]
  id?: Prisma.UuidFilter<"XPost"> | string
  userId?: Prisma.UuidFilter<"XPost"> | string
  battleId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  battleParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  challengeParticipantId?: Prisma.UuidNullableFilter<"XPost"> | string | null
  postType?: Prisma.EnumPostTypeFilter<"XPost"> | $Enums.PostType
  mediaUrl?: Prisma.StringNullableFilter<"XPost"> | string | null
  caption?: Prisma.StringNullableFilter<"XPost"> | string | null
  like?: Prisma.IntFilter<"XPost"> | number
  comment?: Prisma.IntFilter<"XPost"> | number
  share?: Prisma.IntFilter<"XPost"> | number
  createdAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"XPost"> | Date | string
}

export type XPostCreateWithoutBattleEntriesInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
}

export type XPostUncheckedCreateWithoutBattleEntriesInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
}

export type XPostCreateOrConnectWithoutBattleEntriesInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleEntriesInput, Prisma.XPostUncheckedCreateWithoutBattleEntriesInput>
}

export type XPostUpsertWithoutBattleEntriesInput = {
  update: Prisma.XOR<Prisma.XPostUpdateWithoutBattleEntriesInput, Prisma.XPostUncheckedUpdateWithoutBattleEntriesInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleEntriesInput, Prisma.XPostUncheckedCreateWithoutBattleEntriesInput>
  where?: Prisma.XPostWhereInput
}

export type XPostUpdateToOneWithWhereWithoutBattleEntriesInput = {
  where?: Prisma.XPostWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutBattleEntriesInput, Prisma.XPostUncheckedUpdateWithoutBattleEntriesInput>
}

export type XPostUpdateWithoutBattleEntriesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutBattleEntriesInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
}

export type XPostCreateWithoutBattleParticipantInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutBattleParticipantInput = {
  id?: string
  userId: string
  battleId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutBattleParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput>
}

export type XPostCreateManyBattleParticipantInputEnvelope = {
  data: Prisma.XPostCreateManyBattleParticipantInput | Prisma.XPostCreateManyBattleParticipantInput[]
  skipDuplicates?: boolean
}

export type XPostUpsertWithWhereUniqueWithoutBattleParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  update: Prisma.XOR<Prisma.XPostUpdateWithoutBattleParticipantInput, Prisma.XPostUncheckedUpdateWithoutBattleParticipantInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutBattleParticipantInput, Prisma.XPostUncheckedCreateWithoutBattleParticipantInput>
}

export type XPostUpdateWithWhereUniqueWithoutBattleParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutBattleParticipantInput, Prisma.XPostUncheckedUpdateWithoutBattleParticipantInput>
}

export type XPostUpdateManyWithWhereWithoutBattleParticipantInput = {
  where: Prisma.XPostScalarWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyWithoutBattleParticipantInput>
}

export type XPostCreateWithoutChallengeInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutChallengeInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutChallengeInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput>
}

export type XPostCreateManyChallengeInputEnvelope = {
  data: Prisma.XPostCreateManyChallengeInput | Prisma.XPostCreateManyChallengeInput[]
  skipDuplicates?: boolean
}

export type XPostUpsertWithWhereUniqueWithoutChallengeInput = {
  where: Prisma.XPostWhereUniqueInput
  update: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeInput, Prisma.XPostUncheckedUpdateWithoutChallengeInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeInput, Prisma.XPostUncheckedCreateWithoutChallengeInput>
}

export type XPostUpdateWithWhereUniqueWithoutChallengeInput = {
  where: Prisma.XPostWhereUniqueInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeInput, Prisma.XPostUncheckedUpdateWithoutChallengeInput>
}

export type XPostUpdateManyWithWhereWithoutChallengeInput = {
  where: Prisma.XPostScalarWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyWithoutChallengeInput>
}

export type XPostCreateWithoutChallengeParticipantInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutChallengeParticipantInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutChallengeParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput>
}

export type XPostCreateManyChallengeParticipantInputEnvelope = {
  data: Prisma.XPostCreateManyChallengeParticipantInput | Prisma.XPostCreateManyChallengeParticipantInput[]
  skipDuplicates?: boolean
}

export type XPostUpsertWithWhereUniqueWithoutChallengeParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  update: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeParticipantInput, Prisma.XPostUncheckedUpdateWithoutChallengeParticipantInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeParticipantInput, Prisma.XPostUncheckedCreateWithoutChallengeParticipantInput>
}

export type XPostUpdateWithWhereUniqueWithoutChallengeParticipantInput = {
  where: Prisma.XPostWhereUniqueInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeParticipantInput, Prisma.XPostUncheckedUpdateWithoutChallengeParticipantInput>
}

export type XPostUpdateManyWithWhereWithoutChallengeParticipantInput = {
  where: Prisma.XPostScalarWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyWithoutChallengeParticipantInput>
}

export type XPostCreateWithoutChallengeSubmissionInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutXpostsInput
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutChallengeSubmissionInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutChallengeSubmissionInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedCreateWithoutChallengeSubmissionInput>
}

export type XPostUpsertWithoutChallengeSubmissionInput = {
  update: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedUpdateWithoutChallengeSubmissionInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedCreateWithoutChallengeSubmissionInput>
  where?: Prisma.XPostWhereInput
}

export type XPostUpdateToOneWithWhereWithoutChallengeSubmissionInput = {
  where?: Prisma.XPostWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutChallengeSubmissionInput, Prisma.XPostUncheckedUpdateWithoutChallengeSubmissionInput>
}

export type XPostUpdateWithoutChallengeSubmissionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutChallengeSubmissionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostCreateWithoutUserInput = {
  id?: string
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  battle?: Prisma.BattleCreateNestedOneWithoutXpostsInput
  battleParticipant?: Prisma.BattleParticipantCreateNestedOneWithoutXpostsInput
  challenge?: Prisma.ChallengeCreateNestedOneWithoutPostsInput
  challengeParticipant?: Prisma.ChallengeParticipantCreateNestedOneWithoutPostsInput
  challengeSubmission?: Prisma.ChallengeSubmissionCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryCreateNestedManyWithoutXpostInput
}

export type XPostUncheckedCreateWithoutUserInput = {
  id?: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedCreateNestedOneWithoutXpostInput
  battleEntries?: Prisma.BattleEntryUncheckedCreateNestedManyWithoutXpostInput
}

export type XPostCreateOrConnectWithoutUserInput = {
  where: Prisma.XPostWhereUniqueInput
  create: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput>
}

export type XPostCreateManyUserInputEnvelope = {
  data: Prisma.XPostCreateManyUserInput | Prisma.XPostCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type XPostUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.XPostWhereUniqueInput
  update: Prisma.XOR<Prisma.XPostUpdateWithoutUserInput, Prisma.XPostUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.XPostCreateWithoutUserInput, Prisma.XPostUncheckedCreateWithoutUserInput>
}

export type XPostUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.XPostWhereUniqueInput
  data: Prisma.XOR<Prisma.XPostUpdateWithoutUserInput, Prisma.XPostUncheckedUpdateWithoutUserInput>
}

export type XPostUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.XPostScalarWhereInput
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyWithoutUserInput>
}

export type XPostCreateManyBattleInput = {
  id?: string
  userId: string
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateWithoutBattleInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutBattleInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateManyWithoutBattleInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostCreateManyBattleParticipantInput = {
  id?: string
  userId: string
  battleId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateWithoutBattleParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutBattleParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateManyWithoutBattleParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostCreateManyChallengeInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateWithoutChallengeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutChallengeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateManyWithoutChallengeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostCreateManyChallengeParticipantInput = {
  id?: string
  userId: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateWithoutChallengeParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutXpostsNestedInput
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutChallengeParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateManyWithoutChallengeParticipantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type XPostCreateManyUserInput = {
  id?: string
  battleId?: string | null
  battleParticipantId?: string | null
  challengeId?: string | null
  challengeParticipantId?: string | null
  postType?: $Enums.PostType
  mediaUrl?: string | null
  caption?: string | null
  like?: number
  comment?: number
  share?: number
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type XPostUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  battle?: Prisma.BattleUpdateOneWithoutXpostsNestedInput
  battleParticipant?: Prisma.BattleParticipantUpdateOneWithoutXpostsNestedInput
  challenge?: Prisma.ChallengeUpdateOneWithoutPostsNestedInput
  challengeParticipant?: Prisma.ChallengeParticipantUpdateOneWithoutPostsNestedInput
  challengeSubmission?: Prisma.ChallengeSubmissionUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  challengeSubmission?: Prisma.ChallengeSubmissionUncheckedUpdateOneWithoutXpostNestedInput
  battleEntries?: Prisma.BattleEntryUncheckedUpdateManyWithoutXpostNestedInput
}

export type XPostUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  battleId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  battleParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  challengeParticipantId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  postType?: Prisma.EnumPostTypeFieldUpdateOperationsInput | $Enums.PostType
  mediaUrl?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  caption?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  like?: Prisma.IntFieldUpdateOperationsInput | number
  comment?: Prisma.IntFieldUpdateOperationsInput | number
  share?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type XPostCountOutputType
 */

export type XPostCountOutputType = {
  battleEntries: number
}

export type XPostCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  battleEntries?: boolean | XPostCountOutputTypeCountBattleEntriesArgs
}

/**
 * XPostCountOutputType without action
 */
export type XPostCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPostCountOutputType
   */
  select?: Prisma.XPostCountOutputTypeSelect<ExtArgs> | null
}

/**
 * XPostCountOutputType without action
 */
export type XPostCountOutputTypeCountBattleEntriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.BattleEntryWhereInput
}


export type XPostSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  battleId?: boolean
  battleParticipantId?: boolean
  challengeId?: boolean
  challengeParticipantId?: boolean
  postType?: boolean
  mediaUrl?: boolean
  caption?: boolean
  like?: boolean
  comment?: boolean
  share?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
  challengeSubmission?: boolean | Prisma.XPost$challengeSubmissionArgs<ExtArgs>
  battleEntries?: boolean | Prisma.XPost$battleEntriesArgs<ExtArgs>
  _count?: boolean | Prisma.XPostCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["xPost"]>

export type XPostSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  battleId?: boolean
  battleParticipantId?: boolean
  challengeId?: boolean
  challengeParticipantId?: boolean
  postType?: boolean
  mediaUrl?: boolean
  caption?: boolean
  like?: boolean
  comment?: boolean
  share?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
}, ExtArgs["result"]["xPost"]>

export type XPostSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  battleId?: boolean
  battleParticipantId?: boolean
  challengeId?: boolean
  challengeParticipantId?: boolean
  postType?: boolean
  mediaUrl?: boolean
  caption?: boolean
  like?: boolean
  comment?: boolean
  share?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
}, ExtArgs["result"]["xPost"]>

export type XPostSelectScalar = {
  id?: boolean
  userId?: boolean
  battleId?: boolean
  battleParticipantId?: boolean
  challengeId?: boolean
  challengeParticipantId?: boolean
  postType?: boolean
  mediaUrl?: boolean
  caption?: boolean
  like?: boolean
  comment?: boolean
  share?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type XPostOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "battleId" | "battleParticipantId" | "challengeId" | "challengeParticipantId" | "postType" | "mediaUrl" | "caption" | "like" | "comment" | "share" | "createdAt" | "updatedAt", ExtArgs["result"]["xPost"]>
export type XPostInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
  challengeSubmission?: boolean | Prisma.XPost$challengeSubmissionArgs<ExtArgs>
  battleEntries?: boolean | Prisma.XPost$battleEntriesArgs<ExtArgs>
  _count?: boolean | Prisma.XPostCountOutputTypeDefaultArgs<ExtArgs>
}
export type XPostIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
}
export type XPostIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  battle?: boolean | Prisma.XPost$battleArgs<ExtArgs>
  battleParticipant?: boolean | Prisma.XPost$battleParticipantArgs<ExtArgs>
  challenge?: boolean | Prisma.XPost$challengeArgs<ExtArgs>
  challengeParticipant?: boolean | Prisma.XPost$challengeParticipantArgs<ExtArgs>
}

export type $XPostPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "XPost"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    battle: Prisma.$BattlePayload<ExtArgs> | null
    battleParticipant: Prisma.$BattleParticipantPayload<ExtArgs> | null
    challenge: Prisma.$ChallengePayload<ExtArgs> | null
    challengeParticipant: Prisma.$ChallengeParticipantPayload<ExtArgs> | null
    challengeSubmission: Prisma.$ChallengeSubmissionPayload<ExtArgs> | null
    battleEntries: Prisma.$BattleEntryPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    battleId: string | null
    battleParticipantId: string | null
    challengeId: string | null
    challengeParticipantId: string | null
    postType: $Enums.PostType
    mediaUrl: string | null
    caption: string | null
    like: number
    comment: number
    share: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["xPost"]>
  composites: {}
}

export type XPostGetPayload<S extends boolean | null | undefined | XPostDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$XPostPayload, S>

export type XPostCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<XPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: XPostCountAggregateInputType | true
  }

export interface XPostDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XPost'], meta: { name: 'XPost' } }
  /**
   * Find zero or one XPost that matches the filter.
   * @param {XPostFindUniqueArgs} args - Arguments to find a XPost
   * @example
   * // Get one XPost
   * const xPost = await prisma.xPost.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends XPostFindUniqueArgs>(args: Prisma.SelectSubset<T, XPostFindUniqueArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one XPost that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {XPostFindUniqueOrThrowArgs} args - Arguments to find a XPost
   * @example
   * // Get one XPost
   * const xPost = await prisma.xPost.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends XPostFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, XPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first XPost that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostFindFirstArgs} args - Arguments to find a XPost
   * @example
   * // Get one XPost
   * const xPost = await prisma.xPost.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends XPostFindFirstArgs>(args?: Prisma.SelectSubset<T, XPostFindFirstArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first XPost that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostFindFirstOrThrowArgs} args - Arguments to find a XPost
   * @example
   * // Get one XPost
   * const xPost = await prisma.xPost.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends XPostFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, XPostFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more XPosts that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all XPosts
   * const xPosts = await prisma.xPost.findMany()
   * 
   * // Get first 10 XPosts
   * const xPosts = await prisma.xPost.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const xPostWithIdOnly = await prisma.xPost.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends XPostFindManyArgs>(args?: Prisma.SelectSubset<T, XPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a XPost.
   * @param {XPostCreateArgs} args - Arguments to create a XPost.
   * @example
   * // Create one XPost
   * const XPost = await prisma.xPost.create({
   *   data: {
   *     // ... data to create a XPost
   *   }
   * })
   * 
   */
  create<T extends XPostCreateArgs>(args: Prisma.SelectSubset<T, XPostCreateArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many XPosts.
   * @param {XPostCreateManyArgs} args - Arguments to create many XPosts.
   * @example
   * // Create many XPosts
   * const xPost = await prisma.xPost.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends XPostCreateManyArgs>(args?: Prisma.SelectSubset<T, XPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many XPosts and returns the data saved in the database.
   * @param {XPostCreateManyAndReturnArgs} args - Arguments to create many XPosts.
   * @example
   * // Create many XPosts
   * const xPost = await prisma.xPost.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many XPosts and only return the `id`
   * const xPostWithIdOnly = await prisma.xPost.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends XPostCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, XPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a XPost.
   * @param {XPostDeleteArgs} args - Arguments to delete one XPost.
   * @example
   * // Delete one XPost
   * const XPost = await prisma.xPost.delete({
   *   where: {
   *     // ... filter to delete one XPost
   *   }
   * })
   * 
   */
  delete<T extends XPostDeleteArgs>(args: Prisma.SelectSubset<T, XPostDeleteArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one XPost.
   * @param {XPostUpdateArgs} args - Arguments to update one XPost.
   * @example
   * // Update one XPost
   * const xPost = await prisma.xPost.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends XPostUpdateArgs>(args: Prisma.SelectSubset<T, XPostUpdateArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more XPosts.
   * @param {XPostDeleteManyArgs} args - Arguments to filter XPosts to delete.
   * @example
   * // Delete a few XPosts
   * const { count } = await prisma.xPost.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends XPostDeleteManyArgs>(args?: Prisma.SelectSubset<T, XPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more XPosts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many XPosts
   * const xPost = await prisma.xPost.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends XPostUpdateManyArgs>(args: Prisma.SelectSubset<T, XPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more XPosts and returns the data updated in the database.
   * @param {XPostUpdateManyAndReturnArgs} args - Arguments to update many XPosts.
   * @example
   * // Update many XPosts
   * const xPost = await prisma.xPost.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more XPosts and only return the `id`
   * const xPostWithIdOnly = await prisma.xPost.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends XPostUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, XPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one XPost.
   * @param {XPostUpsertArgs} args - Arguments to update or create a XPost.
   * @example
   * // Update or create a XPost
   * const xPost = await prisma.xPost.upsert({
   *   create: {
   *     // ... data to create a XPost
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the XPost we want to update
   *   }
   * })
   */
  upsert<T extends XPostUpsertArgs>(args: Prisma.SelectSubset<T, XPostUpsertArgs<ExtArgs>>): Prisma.Prisma__XPostClient<runtime.Types.Result.GetResult<Prisma.$XPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of XPosts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostCountArgs} args - Arguments to filter XPosts to count.
   * @example
   * // Count the number of XPosts
   * const count = await prisma.xPost.count({
   *   where: {
   *     // ... the filter for the XPosts we want to count
   *   }
   * })
  **/
  count<T extends XPostCountArgs>(
    args?: Prisma.Subset<T, XPostCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], XPostCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a XPost.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends XPostAggregateArgs>(args: Prisma.Subset<T, XPostAggregateArgs>): Prisma.PrismaPromise<GetXPostAggregateType<T>>

  /**
   * Group by XPost.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {XPostGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends XPostGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: XPostGroupByArgs['orderBy'] }
      : { orderBy?: XPostGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, XPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetXPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the XPost model
 */
readonly fields: XPostFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for XPost.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__XPostClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  battle<T extends Prisma.XPost$battleArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$battleArgs<ExtArgs>>): Prisma.Prisma__BattleClient<runtime.Types.Result.GetResult<Prisma.$BattlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  battleParticipant<T extends Prisma.XPost$battleParticipantArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$battleParticipantArgs<ExtArgs>>): Prisma.Prisma__BattleParticipantClient<runtime.Types.Result.GetResult<Prisma.$BattleParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  challenge<T extends Prisma.XPost$challengeArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$challengeArgs<ExtArgs>>): Prisma.Prisma__ChallengeClient<runtime.Types.Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  challengeParticipant<T extends Prisma.XPost$challengeParticipantArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$challengeParticipantArgs<ExtArgs>>): Prisma.Prisma__ChallengeParticipantClient<runtime.Types.Result.GetResult<Prisma.$ChallengeParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  challengeSubmission<T extends Prisma.XPost$challengeSubmissionArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$challengeSubmissionArgs<ExtArgs>>): Prisma.Prisma__ChallengeSubmissionClient<runtime.Types.Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  battleEntries<T extends Prisma.XPost$battleEntriesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.XPost$battleEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$BattleEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the XPost model
 */
export interface XPostFieldRefs {
  readonly id: Prisma.FieldRef<"XPost", 'String'>
  readonly userId: Prisma.FieldRef<"XPost", 'String'>
  readonly battleId: Prisma.FieldRef<"XPost", 'String'>
  readonly battleParticipantId: Prisma.FieldRef<"XPost", 'String'>
  readonly challengeId: Prisma.FieldRef<"XPost", 'String'>
  readonly challengeParticipantId: Prisma.FieldRef<"XPost", 'String'>
  readonly postType: Prisma.FieldRef<"XPost", 'PostType'>
  readonly mediaUrl: Prisma.FieldRef<"XPost", 'String'>
  readonly caption: Prisma.FieldRef<"XPost", 'String'>
  readonly like: Prisma.FieldRef<"XPost", 'Int'>
  readonly comment: Prisma.FieldRef<"XPost", 'Int'>
  readonly share: Prisma.FieldRef<"XPost", 'Int'>
  readonly createdAt: Prisma.FieldRef<"XPost", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"XPost", 'DateTime'>
}
    

// Custom InputTypes
/**
 * XPost findUnique
 */
export type XPostFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter, which XPost to fetch.
   */
  where: Prisma.XPostWhereUniqueInput
}

/**
 * XPost findUniqueOrThrow
 */
export type XPostFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter, which XPost to fetch.
   */
  where: Prisma.XPostWhereUniqueInput
}

/**
 * XPost findFirst
 */
export type XPostFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter, which XPost to fetch.
   */
  where?: Prisma.XPostWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of XPosts to fetch.
   */
  orderBy?: Prisma.XPostOrderByWithRelationInput | Prisma.XPostOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for XPosts.
   */
  cursor?: Prisma.XPostWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` XPosts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` XPosts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of XPosts.
   */
  distinct?: Prisma.XPostScalarFieldEnum | Prisma.XPostScalarFieldEnum[]
}

/**
 * XPost findFirstOrThrow
 */
export type XPostFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter, which XPost to fetch.
   */
  where?: Prisma.XPostWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of XPosts to fetch.
   */
  orderBy?: Prisma.XPostOrderByWithRelationInput | Prisma.XPostOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for XPosts.
   */
  cursor?: Prisma.XPostWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` XPosts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` XPosts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of XPosts.
   */
  distinct?: Prisma.XPostScalarFieldEnum | Prisma.XPostScalarFieldEnum[]
}

/**
 * XPost findMany
 */
export type XPostFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter, which XPosts to fetch.
   */
  where?: Prisma.XPostWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of XPosts to fetch.
   */
  orderBy?: Prisma.XPostOrderByWithRelationInput | Prisma.XPostOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing XPosts.
   */
  cursor?: Prisma.XPostWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` XPosts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` XPosts.
   */
  skip?: number
  distinct?: Prisma.XPostScalarFieldEnum | Prisma.XPostScalarFieldEnum[]
}

/**
 * XPost create
 */
export type XPostCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * The data needed to create a XPost.
   */
  data: Prisma.XOR<Prisma.XPostCreateInput, Prisma.XPostUncheckedCreateInput>
}

/**
 * XPost createMany
 */
export type XPostCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many XPosts.
   */
  data: Prisma.XPostCreateManyInput | Prisma.XPostCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * XPost createManyAndReturn
 */
export type XPostCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * The data used to create many XPosts.
   */
  data: Prisma.XPostCreateManyInput | Prisma.XPostCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * XPost update
 */
export type XPostUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * The data needed to update a XPost.
   */
  data: Prisma.XOR<Prisma.XPostUpdateInput, Prisma.XPostUncheckedUpdateInput>
  /**
   * Choose, which XPost to update.
   */
  where: Prisma.XPostWhereUniqueInput
}

/**
 * XPost updateMany
 */
export type XPostUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update XPosts.
   */
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyInput>
  /**
   * Filter which XPosts to update
   */
  where?: Prisma.XPostWhereInput
  /**
   * Limit how many XPosts to update.
   */
  limit?: number
}

/**
 * XPost updateManyAndReturn
 */
export type XPostUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * The data used to update XPosts.
   */
  data: Prisma.XOR<Prisma.XPostUpdateManyMutationInput, Prisma.XPostUncheckedUpdateManyInput>
  /**
   * Filter which XPosts to update
   */
  where?: Prisma.XPostWhereInput
  /**
   * Limit how many XPosts to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * XPost upsert
 */
export type XPostUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * The filter to search for the XPost to update in case it exists.
   */
  where: Prisma.XPostWhereUniqueInput
  /**
   * In case the XPost found by the `where` argument doesn't exist, create a new XPost with this data.
   */
  create: Prisma.XOR<Prisma.XPostCreateInput, Prisma.XPostUncheckedCreateInput>
  /**
   * In case the XPost was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.XPostUpdateInput, Prisma.XPostUncheckedUpdateInput>
}

/**
 * XPost delete
 */
export type XPostDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
  /**
   * Filter which XPost to delete.
   */
  where: Prisma.XPostWhereUniqueInput
}

/**
 * XPost deleteMany
 */
export type XPostDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which XPosts to delete
   */
  where?: Prisma.XPostWhereInput
  /**
   * Limit how many XPosts to delete.
   */
  limit?: number
}

/**
 * XPost.battle
 */
export type XPost$battleArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Battle
   */
  select?: Prisma.BattleSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Battle
   */
  omit?: Prisma.BattleOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BattleInclude<ExtArgs> | null
  where?: Prisma.BattleWhereInput
}

/**
 * XPost.battleParticipant
 */
export type XPost$battleParticipantArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BattleParticipant
   */
  select?: Prisma.BattleParticipantSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BattleParticipant
   */
  omit?: Prisma.BattleParticipantOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BattleParticipantInclude<ExtArgs> | null
  where?: Prisma.BattleParticipantWhereInput
}

/**
 * XPost.challenge
 */
export type XPost$challengeArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Challenge
   */
  select?: Prisma.ChallengeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Challenge
   */
  omit?: Prisma.ChallengeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ChallengeInclude<ExtArgs> | null
  where?: Prisma.ChallengeWhereInput
}

/**
 * XPost.challengeParticipant
 */
export type XPost$challengeParticipantArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ChallengeParticipant
   */
  select?: Prisma.ChallengeParticipantSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ChallengeParticipant
   */
  omit?: Prisma.ChallengeParticipantOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ChallengeParticipantInclude<ExtArgs> | null
  where?: Prisma.ChallengeParticipantWhereInput
}

/**
 * XPost.challengeSubmission
 */
export type XPost$challengeSubmissionArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the ChallengeSubmission
   */
  select?: Prisma.ChallengeSubmissionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the ChallengeSubmission
   */
  omit?: Prisma.ChallengeSubmissionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ChallengeSubmissionInclude<ExtArgs> | null
  where?: Prisma.ChallengeSubmissionWhereInput
}

/**
 * XPost.battleEntries
 */
export type XPost$battleEntriesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BattleEntry
   */
  select?: Prisma.BattleEntrySelect<ExtArgs> | null
  /**
   * Omit specific fields from the BattleEntry
   */
  omit?: Prisma.BattleEntryOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BattleEntryInclude<ExtArgs> | null
  where?: Prisma.BattleEntryWhereInput
  orderBy?: Prisma.BattleEntryOrderByWithRelationInput | Prisma.BattleEntryOrderByWithRelationInput[]
  cursor?: Prisma.BattleEntryWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.BattleEntryScalarFieldEnum | Prisma.BattleEntryScalarFieldEnum[]
}

/**
 * XPost without action
 */
export type XPostDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the XPost
   */
  select?: Prisma.XPostSelect<ExtArgs> | null
  /**
   * Omit specific fields from the XPost
   */
  omit?: Prisma.XPostOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.XPostInclude<ExtArgs> | null
}
